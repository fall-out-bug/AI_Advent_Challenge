"""Fallback deterministic parser for intent parsing.

Extracted from IntentOrchestrator to follow Single Responsibility Principle.
Following the Zen of Python: Simple is better than complex.
"""

import re
from datetime import datetime, time, timedelta
from typing import Optional

from src.domain.entities.intent import IntentParseResult
from src.domain.exceptions.intent_exceptions import FallbackParseError

# Fallback parser constants
PRIORITY_KEYWORDS = {
    "high": {"urgent", "high", "asap", "срочно", "важно", "высокий"},
    "medium": {"soon", "important", "medium", "скоро", "важный", "средний"},
    "low": {"later", "low", "someday", "позже", "низкий"},
}

TIME_EXPRESSIONS = {
    "ru": {
        "today": {"сегодня", "сегодняшний"},
        "tomorrow": {"завтра", "завтрашний"},
        "yesterday": {"вчера"},
    },
    "en": {
        "today": {"today"},
        "tomorrow": {"tomorrow"},
        "yesterday": {"yesterday"},
    },
}


class IntentFallbackParser:
    """Deterministic fallback parser for task intent.

    Used when LLM parsing is unavailable or fails.
    Follows single responsibility: extract task fields from text deterministically.
    """

    def parse(self, text: str, context: dict) -> IntentParseResult:
        """Parse intent using deterministic rules.

        Args:
            text: User input text
            context: Conversation context (unused in fallback parser)

        Returns:
            IntentParseResult with extracted fields

        Raises:
            FallbackParseError: If parsing fails unexpectedly
        """
        try:
            deadline_iso = self._extract_iso_datetime(text)
            priority = self._infer_priority(text)
            title = self._extract_task_title(text)
            description = None

            needs_clarification = deadline_iso is None or not title
            questions: list[str] = []
            if needs_clarification:
                # Questions will be generated by IntentClarificationGenerator
                questions = []

            return IntentParseResult(
                title=title,
                description=description,
                deadline_iso=deadline_iso,
                priority=priority,
                tags=[],
                needs_clarification=needs_clarification,
                questions=questions,
            )
        except Exception as e:
            raise FallbackParseError(
                f"Fallback parsing failed: {e}", original_error=e
            ) from e

    def _extract_task_title(self, text: str) -> str:
        """Extract task title by removing command words and time expressions.

        Args:
            text: Natural language input

        Returns:
            Cleaned task title
        """
        cleaned = text

        command_words = [
            "напомни",
            "напомнить",
            "remind",
            "remind me",
            "remind me to",
            "добавь",
            "добавить",
            "add",
            "create",
            "создай",
            "создать",
            "сделай",
            "сделать",
            "do",
            "make",
        ]

        for cmd in command_words:
            pattern = rf"^{re.escape(cmd)}\s+"
            cleaned = re.sub(pattern, "", cleaned, flags=re.IGNORECASE)

        time_patterns = [
            r"(?:завтра|tomorrow|сегодня|today|вчера|yesterday)\s+в\s+\d{1,2}(?::\d{2})?\s*(?:утра|утром|am|morning|дня|днем|pm|afternoon|вечера|вечером|evening|ночи|ночью|night)?",
            r"(?:завтра|tomorrow|сегодня|today|вчера|yesterday)\s+at\s+\d{1,2}(?::\d{2})?\s*(?:am|pm|morning|afternoon|evening|night)?",
            r"(?:завтра|tomorrow|сегодня|today|вчера|yesterday)\s+",
            r"\s+в\s+\d{1,2}(?::\d{2})?\s*(?:утра|утром|am|morning|дня|днем|pm|afternoon|вечера|вечером|evening|ночи|ночью|night)?",
            r"\s+at\s+\d{1,2}(?::\d{2})?\s*(?:am|pm|morning|afternoon|evening|night)?",
            r"\s+\d{1,2}(?::\d{2})?\s*(?:утра|утром|am|morning|дня|днем|pm|afternoon|вечера|вечером|evening|ночи|ночью|night)",
            r"\s+\d{4}-\d{2}-\d{2}(?:\s+\d{2}:\d{2})?",
        ]

        for pattern in time_patterns:
            cleaned = re.sub(pattern, "", cleaned, flags=re.IGNORECASE)

        cleaned = re.sub(r"\s+", " ", cleaned).strip()
        return cleaned if cleaned else text.strip()

    def _extract_iso_datetime(self, text: str) -> Optional[str]:
        """Extract ISO datetime from natural language text.

        Args:
            text: Natural language text

        Returns:
            ISO datetime string or None
        """
        text_lower = text.lower()
        now = datetime.now()

        # Try ISO format first
        patterns = [
            r"(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2})",
            r"(\d{4}-\d{2}-\d{2})",
        ]
        for pat in patterns:
            m = re.search(pat, text)
            if m:
                date_part = m.group(1)
                time_part = m.group(2) if m.lastindex and m.lastindex >= 2 else "00:00"
                try:
                    dt = datetime.fromisoformat(f"{date_part} {time_part}")
                    return dt.isoformat()
                except Exception:
                    continue

        # Extract date offset (today/tomorrow/yesterday)
        date_offset = self._extract_date_offset(text_lower)
        target_date = now.date()
        if date_offset != 0:
            target_date = (now + timedelta(days=date_offset)).date()

        # Extract time
        time_value = self._extract_time_from_text(text)
        if time_value is None:
            return None

        try:
            dt = datetime.combine(target_date, time_value)
            if dt < now and date_offset == 0:
                dt = datetime.combine(target_date + timedelta(days=1), time_value)
            return dt.isoformat()
        except Exception:
            return None

    def _extract_date_offset(self, text_lower: str) -> int:
        """Extract date offset from text (today=0, tomorrow=1, yesterday=-1).

        Args:
            text_lower: Lowercase text

        Returns:
            Date offset in days
        """
        ru_expr = TIME_EXPRESSIONS["ru"]
        en_expr = TIME_EXPRESSIONS["en"]

        if any(word in text_lower for word in ru_expr["tomorrow"]):
            return 1
        if any(word in text_lower for word in ru_expr["today"]):
            return 0
        if any(word in text_lower for word in ru_expr["yesterday"]):
            return -1
        if any(word in text_lower for word in en_expr["tomorrow"]):
            return 1
        if any(word in text_lower for word in en_expr["today"]):
            return 0
        if any(word in text_lower for word in en_expr["yesterday"]):
            return -1

        return 0

    def _extract_time_from_text(self, text: str) -> Optional[time]:
        """Extract time from natural language text.

        Args:
            text: Natural language text

        Returns:
            time object or None
        """
        text_lower = text.lower()

        time_patterns = [
            r"(?:в|at|время|time)\s*(\d{1,2})(?::(\d{2}))?\s*(?:утра|утром|am|morning|дня|днем|pm|afternoon|вечера|вечером|evening|ночи|ночью|night)?",
            r"^(\d{1,2})(?::(\d{2}))?\s*(?:утра|утром|am|morning|дня|днем|pm|afternoon|вечера|вечером|evening|ночи|ночью|night)",
            r"(\d{1,2})(?::(\d{2}))?\s*(?:утра|утром|am|morning|дня|днем|pm|afternoon|вечера|вечером|evening|ночи|ночью|night)",
            r"(?:в|at)\s*(\d{1,2})(?::(\d{2}))?",
            r"(\d{1,2}):(\d{2})",
        ]

        for pattern in time_patterns:
            match = re.search(pattern, text_lower)
            if match:
                hour_str = match.group(1)
                minute_str = (
                    match.group(2) if match.lastindex and match.lastindex >= 2 else "00"
                )

                try:
                    hour = int(hour_str)
                    minute = int(minute_str) if minute_str else 0

                    is_pm = self._detect_pm_indicator(text_lower, match)

                    if hour < 12 and is_pm:
                        hour += 12
                    elif hour == 12 and not is_pm:
                        hour = 0

                    if 0 <= hour < 24 and 0 <= minute < 60:
                        return time(hour, minute)
                except (ValueError, IndexError):
                    continue

        return None

    def _detect_pm_indicator(self, text_lower: str, match: re.Match) -> bool:
        """Detect if time is PM based on context.

        Args:
            text_lower: Lowercase text
            match: Regex match object

        Returns:
            True if PM, False if AM
        """
        text_after_match = text_lower[match.end() :]

        pm_indicators = [
            "pm",
            "вечера",
            "вечером",
            "дня",
            "днем",
            "ночи",
            "ночью",
            "night",
            "evening",
            "afternoon",
        ]
        am_indicators = ["am", "утра", "утром", "morning"]

        if any(indicator in text_after_match[:20] for indicator in pm_indicators):
            return True
        if any(indicator in text_after_match[:20] for indicator in am_indicators):
            return False
        if any(indicator in text_lower for indicator in pm_indicators):
            return True

        return False

    def _infer_priority(self, text: str) -> str:
        """Infer priority from text keywords.

        Args:
            text: Natural language text

        Returns:
            Priority level: "low", "medium", or "high"
        """
        lowered = text.lower()
        for level, keywords in PRIORITY_KEYWORDS.items():
            if any(k in lowered for k in keywords):
                return level
        return "medium"
