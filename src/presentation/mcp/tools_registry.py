"""MCP Tools Registry for discovering and caching tools.

Following Python Zen:
- Simple is better than complex
- Explicit is better than implicit
- Readability counts
"""

import logging
import os
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from src.domain.agents.schemas import ToolMetadata
from src.presentation.mcp.client import MCPClientProtocol

logger = logging.getLogger(__name__)

DEFAULT_TOOL_STATUS = "supported"
HIDDEN_STATUSES = {"deprecated", "archived"}
DEPRECATED_ENV_FLAG = "MCP_INCLUDE_DEPRECATED_TOOLS"
TOOL_STATUS_OVERRIDES: Dict[str, Tuple[str, str]] = {
    # NLP tools
    "parse_digest_intent": (
        "supported",
        "Primary NLP entry point for digest flows.",
    ),
    "parse_task_intent": (
        "archived",
        "Task/reminder flows removed; tool scheduled for EP04 archival.",
    ),
    # Channel digest
    "get_channel_digest_by_name": (
        "supported",
        "Generates digest for a single channel; align templates with CLI outputs.",
    ),
    "get_channel_digest": (
        "supported",
        "Generates digest for all subscriptions; subject to Stage 02_02 refactor.",
    ),
    "request_channel_digest_async": (
        "supported",
        "Queues background digest job; ensure worker coverage remains.",
    ),
    # Channel metadata / resolution
    "get_channel_metadata": (
        "supported",
        "Keeps Mongo and Telegram lookup available for CLI integration.",
    ),
    "resolve_channel_name": (
        "supported",
        "Assists channel lookup; retain for bot and CLI parity.",
    ),
    # Channel management (moving to CLI)
    "add_channel": (
        "transition",
        "Bulk channel management migrates to CLI backoffice in Stage 02_02.",
    ),
    "list_channels": (
        "transition",
        "Read-only listing retained until CLI replaces this surface.",
    ),
    "delete_channel": (
        "transition",
        "Channel removal shifts to CLI commands; keep MCP hook temporarily.",
    ),
    # Posts management (moving to CLI)
    "get_posts": (
        "transition",
        "Posts retrieval will be orchestrated via CLI; MCP usage discouraged.",
    ),
    "collect_posts": (
        "transition",
        (
            "Telegram harvesting migrates to CLI workflows; expect removal post "
            "Stage 02_03."
        ),
    ),
    "save_posts_to_db": (
        "transition",
        "Used by legacy flows; move to deterministic CLI pipeline.",
    ),
    # Homework review
    "review_homework_archive": (
        "deprecated",
        "Replaced by modular reviewer MCP tool after EP01 refactor.",
    ),
    # PDF digest tools
    "get_posts_from_db": (
        "deprecated",
        "PDF digest replaced by Stage 02_02 CLI digest:export command.",
    ),
    "summarize_posts": (
        "deprecated",
        "Summaries handled by CLI pipeline; MCP tool slated for removal.",
    ),
    "format_digest_markdown": (
        "deprecated",
        (
            "Formatting moves to CLI renderer; keep for backward compatibility "
            "only."
        ),
    ),
    "combine_markdown_sections": (
        "deprecated",
        "Combined markdown generated by CLI templates going forward.",
    ),
    "convert_markdown_to_pdf": (
        "deprecated",
        "PDF export handled externally; WeasyPrint dependency will be removed.",
    ),
    # Reminder tools (archived)
    "add_task": (
        "archived",
        "Reminder flows archived; MCP hook retained for short-lived compatibility.",
    ),
    "list_tasks": (
        "archived",
        "Reminder flows archived; tool pending removal with EP04.",
    ),
    "update_task": (
        "archived",
        "Reminder flows archived; tool pending removal with EP04.",
    ),
    "delete_task": (
        "archived",
        "Reminder flows archived; tool pending removal with EP04.",
    ),
    "get_summary": (
        "archived",
        "Reminder summary deprecated; remove once archival sweep completes.",
    ),
}


class MCPToolsRegistry:
    """Registry for MCP tools discovery and caching.

    Purpose:
        Discover MCP tools and build prompt sections describing them.
        Cache tools in memory to avoid repeated discovery.

    Example:
        >>> from src.presentation.mcp.tools_registry import MCPToolsRegistry
        >>> from src.presentation.mcp.client import MCPClient
        >>>
        >>> client = MCPClient()
        >>> registry = MCPToolsRegistry(mcp_client=client)
        >>> tools = await registry.discover_tools()
        >>> prompt = registry.build_tools_prompt()
    """

    def __init__(self, mcp_client: MCPClientProtocol, cache_ttl_seconds: int = 300):
        """Initialize registry.

        Args:
            mcp_client: MCP client for discovering tools
            cache_ttl_seconds: Cache TTL in seconds (default 5 minutes)
        """
        self.mcp_client = mcp_client
        self.cache_ttl_seconds = cache_ttl_seconds
        self._tools: Optional[List[ToolMetadata]] = None
        self._cache_timestamp: Optional[datetime] = None
        self._include_deprecated = (
            os.getenv(DEPRECATED_ENV_FLAG, "0").lower()
            not in {"", "0", "false", "no"}
        )

    async def discover_tools(self) -> List[ToolMetadata]:
        """Discover all available MCP tools.

        Returns:
            List of tool metadata

        Raises:
            Exception: If tool discovery fails
        """
        if self._is_cache_valid():
            return self._tools or []

        raw_tools = await self._fetch_tools()
        filtered_tools = self._filter_by_status(raw_tools)
        parsed_tools = self._parse_tool_metadata(filtered_tools)
        self._cache_tools(parsed_tools)
        return parsed_tools

    def _is_cache_valid(self) -> bool:
        """Check if cache is still valid.

        Returns:
            True if cache is valid, False otherwise
        """
        if self._tools is None or self._cache_timestamp is None:
            return False

        elapsed = (datetime.utcnow() - self._cache_timestamp).total_seconds()
        return elapsed < self.cache_ttl_seconds

    async def _fetch_tools(self) -> List[dict]:
        """Fetch tools from MCP client.

        Returns:
            List of raw tool dictionaries

        Raises:
            Exception: If fetch fails
        """
        try:
            return await self.mcp_client.discover_tools()
        except Exception as e:
            logger.error(f"Failed to fetch tools: {e}")
            raise

    def _filter_by_status(self, raw_tools: List[dict]) -> List[dict]:
        """Filter tools based on lifecycle status.

        Args:
            raw_tools: Raw tool dictionaries from MCP.

        Returns:
            Filtered list of tool dictionaries.
        """
        filtered: List[dict] = []
        for tool in raw_tools:
            name = tool.get("name", "")
            override = TOOL_STATUS_OVERRIDES.get(name)
            status = override[0] if override else DEFAULT_TOOL_STATUS

            if status in HIDDEN_STATUSES and not self._include_deprecated:
                logger.debug(
                    "Skipping %s tool '%s' during discovery", status, name
                )
                continue

            filtered.append(tool)
        return filtered

    def _parse_tool_metadata(self, raw_tools: List[dict]) -> List[ToolMetadata]:
        """Parse raw tools into ToolMetadata objects.

        Args:
            raw_tools: Raw tool dictionaries from MCP

        Returns:
            List of ToolMetadata objects
        """
        parsed: List[ToolMetadata] = []
        for tool in raw_tools:
            try:
                name = tool["name"]
                description = tool["description"]
                override = TOOL_STATUS_OVERRIDES.get(name)
                status = override[0] if override else DEFAULT_TOOL_STATUS
                note = override[1] if override else None

                metadata = ToolMetadata(
                    name=name,
                    description=self._augment_description(
                        description, status, note
                    ),
                    input_schema=tool.get("input_schema", {}),
                    status=status,
                    note=note,
                )
                parsed.append(metadata)
            except Exception as e:
                logger.warning(
                    f"Failed to parse tool {tool.get('name', 'unknown')}: {e}"
                )
        return parsed

    @staticmethod
    def _augment_description(
        description: str, status: str, note: Optional[str]
    ) -> str:
        """Append lifecycle details to tool description."""
        status_prefix = f"[{status.upper()}] "
        note_suffix = f" â€” {note}" if note else ""
        return f"{status_prefix}{description}{note_suffix}"

    def _cache_tools(self, tools: List[ToolMetadata]) -> None:
        """Cache tools in memory.

        Args:
            tools: List of tools to cache
        """
        self._tools = tools
        self._cache_timestamp = datetime.utcnow()
        logger.debug(f"Cached {len(tools)} tools")

    def build_tools_prompt(self) -> str:
        """Build prompt section describing all tools.

        Returns:
            Formatted prompt text with tool descriptions
        """
        if not self._tools:
            return "No tools available."

        sections = ["Available tools:"]
        for tool in self._tools:
            section = self._format_tool_description(tool)
            sections.append(section)

        return "\n\n".join(sections)

    def _format_tool_description(self, tool: ToolMetadata) -> str:
        """Format single tool description.

        Args:
            tool: Tool metadata

        Returns:
            Formatted tool description string
        """
        params = self._extract_parameters(tool.input_schema)
        param_desc = ", ".join(params) if params else "no parameters"
        status_line = f"Status: {tool.status}"
        if tool.note:
            status_line = f"{status_line} ({tool.note})"

        return (
            f"- {tool.name}: {tool.description}\n"
            f"  {status_line}\n"
            f"  Parameters: {param_desc}"
        )

    def _extract_parameters(self, schema: dict) -> List[str]:
        """Extract parameter names from schema.

        Args:
            schema: JSON schema dictionary

        Returns:
            List of parameter names
        """
        props = schema.get("properties", {})
        required = schema.get("required", [])

        params = []
        for param_name, param_schema in props.items():
            param_type = param_schema.get("type", "any")
            required_mark = "*" if param_name in required else ""
            params.append(f"{param_name}{required_mark}({param_type})")

        return params
