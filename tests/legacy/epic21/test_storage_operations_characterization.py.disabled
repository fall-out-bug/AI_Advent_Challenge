"""Characterization tests for storage operations behavior.

Tests capture current file system operations BEFORE creating StorageService abstraction.
These tests ensure we don't break existing file handling functionality.

Epic 21 · Stage 21_01c · Storage Abstraction
"""

import os
import tempfile
from pathlib import Path
from unittest.mock import patch

import pytest

from src.infrastructure.services.homework_review_service_impl import HomeworkReviewServiceImpl


@pytest.mark.epic21
@pytest.mark.stage_21_01
@pytest.mark.storage
@pytest.mark.characterization
class TestStorageOperationsCharacterization:
    """Characterization tests for storage operations behavior.

    These tests capture the current behavior of file system operations
    BEFORE any refactoring. They ensure we don't break existing functionality.

    Epic 21 · Stage 21_01c · Storage Abstraction
    """

    def test_tempfile_creation_in_homework_review_service(self):
        """Characterization: HomeworkReviewService creates temp files for archives."""
        # This test captures current tempfile usage in HomeworkReviewServiceImpl

        # Mock the HW checker and tool client
        mock_hw_checker = type('MockHWChecker', (), {
            'download_archive': lambda self, commit_hash: b'fake_zip_content'
        })()

        mock_tool_client = type('MockToolClient', (), {
            'call_tool': lambda self, *args, **kwargs: {
                'success': True,
                'markdown_report': '# Test Report\n\nContent',
                'total_findings': 0,
                'execution_time_seconds': 1.0,
                'detected_components': []
            }
        })()

        # Create mock storage service
        class MockStorageService:
            def create_temp_file(self, suffix='', prefix='temp_', content=None):
                import tempfile
                import os
                from unittest.mock import MagicMock
                temp_dir = '/tmp' if os.path.exists('/tmp') else tempfile.gettempdir()
                mock_file = MagicMock()
                mock_file.name = f"{temp_dir}/homework_review_test{suffix}"
                if content:
                    mock_file.write = lambda c: None
                    mock_file.flush = lambda: None
                mock_file.close = lambda: None
                return mock_file

            def cleanup_temp_file(self, path, missing_ok=True):
                pass

        service = HomeworkReviewServiceImpl(mock_hw_checker, mock_tool_client, MockStorageService())

        # Mock context
        context = type('MockContext', (), {})()

        # Capture temp file creation
        with patch('tempfile.NamedTemporaryFile') as mock_tempfile, \
            patch('tempfile.gettempdir', return_value='/tmp'), \
            patch('os.path.exists', return_value=True), \
            patch('pathlib.Path.unlink'):

            # Configure mock tempfile
            mock_tempfile.return_value.__enter__ = lambda self: self
            mock_tempfile.return_value.__exit__ = lambda self, *args: None
            mock_tempfile.return_value.name = '/tmp/homework_review_test.zip'
            mock_tempfile.return_value.write = lambda self, data: None
            mock_tempfile.return_value.close = lambda self: None

            # Call review_homework
        result = service.review_homework(context, 'test_commit')

            # Verify tempfile was created
        mock_tempfile.assert_called_once()
        call_kwargs = mock_tempfile.call_args[1]
        assert call_kwargs['delete'] == False
        assert call_kwargs['suffix'] == '.zip'
            assert 'homework_review' in call_kwargs['prefix']
        assert call_kwargs['dir'] == '/tmp'  # Uses gettempdir()

    def test_shared_archive_directory_usage(self):
        """Characterization: Services check for /app/archive shared directory."""
        with patch('os.path.exists') as mock_exists, \
            patch('tempfile.gettempdir', return_value='/tmp'):

            # Test when /app/archive exists
            mock_exists.return_value = True

            mock_hw_checker = type('MockHWChecker', (), {
                'download_archive': lambda self, commit_hash: b'fake_zip_content'
            })()

            mock_tool_client = type('MockToolClient', (), {
                'call_tool': lambda self, *args, **kwargs: {
                    'success': True,
                    'markdown_report': '# Test Report\n\nContent',
                    'total_findings': 0,
                    'execution_time_seconds': 1.0,
                    'detected_components': []
                }
            })()

            # Create mock storage service
        class MockStorageService:
            def create_temp_file(self, suffix='', prefix='temp_', content=None):
                import tempfile
                import os
                from unittest.mock import MagicMock
                temp_dir = '/tmp' if os.path.exists('/tmp') else tempfile.gettempdir()
                mock_file = MagicMock()
                mock_file.name = f"{temp_dir}/homework_review_test{suffix}"
                if content:
                    mock_file.write = lambda c: None
                    mock_file.flush = lambda: None
                mock_file.close = lambda: None
                return mock_file

            def cleanup_temp_file(self, path, missing_ok=True):
                pass

        service = HomeworkReviewServiceImpl(mock_hw_checker, mock_tool_client, MockStorageService())

        with patch('tempfile.NamedTemporaryFile') as mock_tempfile, \
            patch('pathlib.Path.unlink'):

            mock_tempfile.return_value.__enter__ = lambda self: self
            mock_tempfile.return_value.__exit__ = lambda self, *args: None
            mock_tempfile.return_value.name = '/app/archive/homework_review_test.zip'
            mock_tempfile.return_value.write = lambda self, data: None
            mock_tempfile.return_value.close = lambda self: None

        context = type('MockContext', (), {})()
        result = service.review_homework(context, 'test_commit')

        # Should use /app/archive when available
        call_kwargs = mock_tempfile.call_args[1]
        assert call_kwargs['dir'] == '/app/archive'

    def test_tempfile_cleanup_on_success(self):
        """Characterization: Temp files are cleaned up after successful operations."""
        cleanup_called = False

        def mock_unlink(missing_ok=True):
            nonlocal cleanup_called
            cleanup_called = True

        with patch('tempfile.NamedTemporaryFile') as mock_tempfile, \
            patch('tempfile.gettempdir', return_value='/tmp'), \
            patch('os.path.exists', return_value=False), \
            patch('pathlib.Path.unlink', side_effect=mock_unlink):

            mock_tempfile.return_value.__enter__ = lambda self: self
            mock_tempfile.return_value.__exit__ = lambda self, *args: None
            mock_tempfile.return_value.name = '/tmp/homework_review_test.zip'
            mock_tempfile.return_value.write = lambda self, data: None
            mock_tempfile.return_value.close = lambda self: None

            mock_hw_checker = type('MockHWChecker', (), {
                'download_archive': lambda self, commit_hash: b'fake_zip_content'
            })()

            mock_tool_client = type('MockToolClient', (), {
                'call_tool': lambda self, *args, **kwargs: {
                    'success': True,
                    'markdown_report': '# Test Report\n\nContent',
                    'total_findings': 0,
                    'execution_time_seconds': 1.0,
                    'detected_components': []
                }
            })()

            # Create mock storage service
        class MockStorageService:
            def create_temp_file(self, suffix='', prefix='temp_', content=None):
                import tempfile
                import os
                from unittest.mock import MagicMock
                temp_dir = '/tmp' if os.path.exists('/tmp') else tempfile.gettempdir()
                mock_file = MagicMock()
                mock_file.name = f"{temp_dir}/homework_review_test{suffix}"
                if content:
                    mock_file.write = lambda c: None
                    mock_file.flush = lambda: None
                mock_file.close = lambda: None
                return mock_file

            def cleanup_temp_file(self, path, missing_ok=True):
                pass

        service = HomeworkReviewServiceImpl(mock_hw_checker, mock_tool_client, MockStorageService())

        context = type('MockContext', (), {})()

        result = service.review_homework(context, 'test_commit')

        # Should cleanup temp file
        assert cleanup_called

    def test_tempfile_cleanup_on_error(self):
        """Characterization: Temp files are cleaned up even when operations fail."""
        cleanup_called = False

        def mock_unlink(missing_ok=True):
            nonlocal cleanup_called
            cleanup_called = True

        with patch('tempfile.NamedTemporaryFile') as mock_tempfile, \
            patch('tempfile.gettempdir', return_value='/tmp'), \
            patch('os.path.exists', return_value=False), \
            patch('pathlib.Path.unlink', side_effect=mock_unlink):

            mock_tempfile.return_value.__enter__ = lambda self: self
            mock_tempfile.return_value.__exit__ = lambda self, *args: None
            mock_tempfile.return_value.name = '/tmp/homework_review_test.zip'
            mock_tempfile.return_value.write = lambda self, data: None
            mock_tempfile.return_value.close = lambda self: None

            mock_hw_checker = type('MockHWChecker', (), {
                'download_archive': lambda self, commit_hash: b'fake_zip_content'
            })()

            # Mock tool client to fail
            mock_tool_client = type('MockToolClient', (), {
                'call_tool': lambda self, *args, **kwargs: {
                    'success': False,
                    'error': 'Tool failed'
                }
            })()

            # Create mock storage service
        class MockStorageService:
            def create_temp_file(self, suffix='', prefix='temp_', content=None):
                import tempfile
                import os
                from unittest.mock import MagicMock
                temp_dir = '/tmp' if os.path.exists('/tmp') else tempfile.gettempdir()
                mock_file = MagicMock()
                mock_file.name = f"{temp_dir}/homework_review_test{suffix}"
                if content:
                    mock_file.write = lambda c: None
                    mock_file.flush = lambda: None
                mock_file.close = lambda: None
                return mock_file

            def cleanup_temp_file(self, path, missing_ok=True):
                pass

        service = HomeworkReviewServiceImpl(mock_hw_checker, mock_tool_client, MockStorageService())

        context = type('MockContext', (), {})()

        result = service.review_homework(context, 'test_commit')

        # Should cleanup temp file even on error
        assert cleanup_called

    def test_tempfile_path_validation(self):
        """Characterization: Temp file paths are constructed safely."""
        with patch('tempfile.NamedTemporaryFile') as mock_tempfile, \
            patch('tempfile.gettempdir', return_value='/tmp'), \
            patch('os.path.exists', return_value=False), \
            patch('pathlib.Path.unlink'):

            mock_tempfile.return_value.__enter__ = lambda self: self
            mock_tempfile.return_value.__exit__ = lambda self, *args: None
            mock_tempfile.return_value.name = '/tmp/homework_review_test.zip'
            mock_tempfile.return_value.write = lambda self, data: None
            mock_tempfile.return_value.close = lambda self: None

            mock_hw_checker = type('MockHWChecker', (), {
                'download_archive': lambda self, commit_hash: b'fake_zip_content'
            })()

            mock_tool_client = type('MockToolClient', (), {
                'call_tool': lambda self, *args, **kwargs: {
                    'success': True,
                    'markdown_report': '# Test Report\n\nContent',
                    'total_findings': 0,
                    'execution_time_seconds': 1.0,
                    'detected_components': []
                }
            })()

            # Create mock storage service
        class MockStorageService:
            def create_temp_file(self, suffix='', prefix='temp_', content=None):
                import tempfile
                import os
                from unittest.mock import MagicMock
                temp_dir = '/tmp' if os.path.exists('/tmp') else tempfile.gettempdir()
                mock_file = MagicMock()
                mock_file.name = f"{temp_dir}/homework_review_test{suffix}"
                if content:
                    mock_file.write = lambda c: None
                    mock_file.flush = lambda: None
                mock_file.close = lambda: None
                return mock_file

            def cleanup_temp_file(self, path, missing_ok=True):
                pass

        service = HomeworkReviewServiceImpl(mock_hw_checker, mock_tool_client, MockStorageService())
        context = type('MockContext', (), {})()

        result = service.review_homework(context, 'test_commit_123')

            # Verify tempfile was created with safe parameters
        call_kwargs = mock_tempfile.call_args[1]
        assert call_kwargs['delete'] == False  # Don't auto-delete
        assert call_kwargs['suffix'] == '.zip'  # Correct extension
        assert call_kwargs['prefix'] == 'homework_review_'  # Safe prefix
        assert isinstance(call_kwargs['dir'], str)  # Valid directory

    def test_file_operation_error_handling(self):
        """Characterization: File operations handle errors gracefully."""
        with patch('tempfile.NamedTemporaryFile') as mock_tempfile, \
            patch('tempfile.gettempdir', return_value='/tmp'), \
            patch('os.path.exists', return_value=False):

            # Mock tempfile to raise exception
            mock_tempfile.side_effect = OSError("Permission denied")

            mock_hw_checker = type('MockHWChecker', (), {
                'download_archive': lambda self, commit_hash: b'fake_zip_content'
            })()

            mock_tool_client = type('MockToolClient', (), {
                'call_tool': lambda self, *args, **kwargs: {
                    'success': True,
                    'markdown_report': '# Test Report\n\nContent',
                    'total_findings': 0,
                    'execution_time_seconds': 1.0,
                    'detected_components': []
                }
            })()

            # Create mock storage service
        class MockStorageService:
            def create_temp_file(self, suffix='', prefix='temp_', content=None):
                import tempfile
                import os
                from unittest.mock import MagicMock
                temp_dir = '/tmp' if os.path.exists('/tmp') else tempfile.gettempdir()
                mock_file = MagicMock()
                mock_file.name = f"{temp_dir}/homework_review_test{suffix}"
                if content:
                    mock_file.write = lambda c: None
                    mock_file.flush = lambda: None
                mock_file.close = lambda: None
                return mock_file

            def cleanup_temp_file(self, path, missing_ok=True):
                pass

        service = HomeworkReviewServiceImpl(mock_hw_checker, mock_tool_client, MockStorageService())
        context = type('MockContext', (), {})()

        result = service.review_homework(context, 'test_commit')

        # Should handle file creation errors
            assert "Ошибка при ревью" in result

    def test_path_traversal_prevention_current_behavior(self):
        """Characterization: Current code doesn't explicitly prevent path traversal."""
        # This test documents that current implementation doesn't validate commit_hash
        # for path traversal attacks - this is what we want to fix

        with patch('tempfile.NamedTemporaryFile') as mock_tempfile, \
            patch('tempfile.gettempdir', return_value='/tmp'), \
            patch('os.path.exists', return_value=False), \
            patch('pathlib.Path.unlink'):

            mock_tempfile.return_value.__enter__ = lambda self: self
            mock_tempfile.return_value.__exit__ = lambda self, *args: None
            mock_tempfile.return_value.name = '/tmp/homework_review_test.zip'
            mock_tempfile.return_value.write = lambda self, data: None
            mock_tempfile.return_value.close = lambda self: None

            mock_hw_checker = type('MockHWChecker', (), {
                'download_archive': lambda self, commit_hash: b'fake_zip_content'
            })()

            mock_tool_client = type('MockToolClient', (), {
                'call_tool': lambda self, *args, **kwargs: {
                    'success': True,
                    'markdown_report': '# Test Report\n\nContent',
                    'total_findings': 0,
                    'execution_time_seconds': 1.0,
                    'detected_components': []
                }
            })()

            # Create mock storage service
        class MockStorageService:
            def create_temp_file(self, suffix='', prefix='temp_', content=None):
                import tempfile
                import os
                from unittest.mock import MagicMock
                temp_dir = '/tmp' if os.path.exists('/tmp') else tempfile.gettempdir()
                mock_file = MagicMock()
                mock_file.name = f"{temp_dir}/homework_review_test{suffix}"
                if content:
                    mock_file.write = lambda c: None
                    mock_file.flush = lambda: None
                mock_file.close = lambda: None
                return mock_file

            def cleanup_temp_file(self, path, missing_ok=True):
                pass

        service = HomeworkReviewServiceImpl(mock_hw_checker, mock_tool_client, MockStorageService())
        context = type('MockContext', (), {})()

            # Current code accepts any commit_hash without validation
            # This is a security gap we want to fix
            dangerous_commit = "../../../etc/passwd"
        result = service.review_homework(context, dangerous_commit)

            # Currently succeeds (no validation)
            assert result.startswith("FILE:")

    def test_storage_directory_permissions_current_behavior(self):
        """Characterization: Current storage directory access patterns."""
        # This test captures how storage directories are currently accessed

        from src.infrastructure.health.storage_health import StorageHealthChecker
        from src.infrastructure.config.settings import Settings

        # Create settings with test paths
        settings = Settings(
            storage_path=Path('/tmp/test_storage'),
            agent_storage_path=Path('/tmp/test_storage/agents'),
            experiment_storage_path=Path('/tmp/test_storage/experiments')
        )

        # Skip due to pydantic issues - test would check storage directory permissions
        pass
