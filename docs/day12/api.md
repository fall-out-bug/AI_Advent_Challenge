# Day 12 - PDF Digest MCP Tools API Documentation

## Overview

This document describes the MCP (Model Context Protocol) tools for PDF digest generation. These tools work together to generate PDF digests from Telegram channel posts stored in MongoDB.

## Tools Overview

The PDF digest system consists of 5 MCP tools:

1. **get_posts_from_db** - Retrieve posts from MongoDB grouped by channel
2. **summarize_posts** - Generate summary for posts using LLM
3. **format_digest_markdown** - Format summaries into markdown sections
4. **combine_markdown_sections** - Combine sections into single document
5. **convert_markdown_to_pdf** - Convert markdown to PDF using weasyprint

## Tool Specifications

### 1. get_posts_from_db

Retrieve posts from MongoDB for user's subscribed channels, grouped by channel with limits applied.

**Request:**
```json
{
  "user_id": 123456789,
  "hours": 24
}
```

**Parameters:**
- `user_id` (int, required): Telegram user ID
- `hours` (int, optional): Hours to look back (default: 24)

**Response:**
```json
{
  "posts_by_channel": {
    "channel1": [
      {
        "id": "507f1f77bcf86cd799439011",
        "channel_username": "channel1",
        "message_id": "12345",
        "text": "Post text content",
        "date": "2024-01-15T20:00:00Z",
        "user_id": 123456789,
        "views": 100,
        "metadata": {}
      }
    ],
    "channel2": [...]
  },
  "total_posts": 42,
  "channels_count": 5
}
```

**Response Fields:**
- `posts_by_channel` (dict): Dictionary mapping channel usernames to post lists
- `total_posts` (int): Total number of posts across all channels
- `channels_count` (int): Number of channels with posts

**Limits:**
- Max 100 posts per channel (configurable via `pdf_max_posts_per_channel`)
- Max 10 channels (configurable via `digest_max_channels`)

**Error Handling:**
- Returns empty result on database errors: `{"posts_by_channel": {}, "total_posts": 0, "channels_count": 0}`
- Errors are logged but not raised

**Example:**
```python
result = await client.call_tool("get_posts_from_db", {
    "user_id": 123456789,
    "hours": 24
})
print(f"Found {result['channels_count']} channels with {result['total_posts']} posts")
```

---

### 2. summarize_posts

Generate summary for posts from a single channel using LLM with ML-engineer limits.

**Request:**
```json
{
  "posts": [
    {
      "text": "Post text content",
      "date": "2024-01-15T20:00:00Z",
      "message_id": "12345"
    }
  ],
  "channel_username": "channel1",
  "max_sentences": 5
}
```

**Parameters:**
- `posts` (list[dict], required): List of post dictionaries with text, date, message_id
- `channel_username` (str, required): Channel username without @
- `max_sentences` (int, optional): Maximum sentences per channel (default: 5)

**Response:**
```json
{
  "summary": "Summary text generated by LLM for the channel posts...",
  "post_count": 10,
  "channel": "channel1"
}
```

**Response Fields:**
- `summary` (str): Generated summary text (max 3000 characters)
- `post_count` (int): Number of posts processed
- `channel` (str): Channel username

**Limits:**
- Max 100 posts per channel (if exceeded, takes most recent 100)
- Max 5-6 sentences per summary (configurable via `pdf_summary_sentences`)
- Max 3000 characters per summary (configurable via `pdf_summary_max_chars`)
- Max 3000 input tokens (within model limits)
- Max 800 output tokens

**Error Handling:**
- Returns fallback summary on LLM errors
- Fallback concatenates first 5 posts (200 chars each)
- Errors are logged but not raised

**Example:**
```python
result = await client.call_tool("summarize_posts", {
    "posts": posts_list,
    "channel_username": "channel1",
    "max_sentences": 5
})
print(result["summary"])
```

---

### 3. format_digest_markdown

Format channel summaries into markdown section with metadata.

**Request:**
```json
{
  "summaries": [
    {
      "channel": "channel1",
      "summary": "Summary text...",
      "post_count": 10
    },
    {
      "channel": "channel2",
      "summary": "Summary text...",
      "post_count": 15
    }
  ],
  "metadata": {
    "generation_date": "2024-01-15T20:00:00Z",
    "user_id": 123456789,
    "channels_count": 2,
    "total_posts": 25
  }
}
```

**Parameters:**
- `summaries` (list[dict], required): List of summaries from `summarize_posts`
- `metadata` (dict, required): Metadata dict with:
  - `generation_date` (str): ISO format date
  - `user_id` (int): Telegram user ID
  - `channels_count` (int): Number of channels
  - `total_posts` (int): Total posts processed

**Response:**
```json
{
  "markdown": "# Channel Digest\n\nGenerated: 2024-01-15T20:00:00Z\nChannels: 2 | Total Posts: 25\n\n## channel1\n\nSummary text...\n\n*Posts processed: 10*\n\n## channel2\n\nSummary text...\n\n*Posts processed: 15*\n",
  "sections_count": 2
}
```

**Response Fields:**
- `markdown` (str): Formatted markdown string
- `sections_count` (int): Number of channel sections

**Markdown Format:**
```markdown
# Channel Digest

Generated: 2024-01-15T20:00:00Z
Channels: 2 | Total Posts: 25

## channel1

Summary text...

*Posts processed: 10*

## channel2

Summary text...

*Posts processed: 15*
```

**Error Handling:**
- Returns error markdown on formatting errors
- Errors are logged but not raised

**Example:**
```python
result = await client.call_tool("format_digest_markdown", {
    "summaries": summaries_list,
    "metadata": metadata_dict
})
markdown_content = result["markdown"]
```

---

### 4. combine_markdown_sections

Combine multiple markdown sections into single document with template.

**Request:**
```json
{
  "sections": [
    "# Channel Digest\n\nGenerated: 2024-01-15T20:00:00Z\n..."
  ],
  "template": "default"
}
```

**Parameters:**
- `sections` (list[str], required): List of markdown section strings
- `template` (str, optional): Template name (default: "default")

**Response:**
```json
{
  "combined_markdown": "# Telegram Channel Digest\n\nGenerated: 2024-01-15T20:00:00Z\n\n---\n\n# Channel Digest\n...\n\n---\n\n*End of digest*\n",
  "total_chars": 1523
}
```

**Response Fields:**
- `combined_markdown` (str): Combined markdown with template
- `total_chars` (int): Total characters in combined markdown

**Template Format:**
```markdown
# Telegram Channel Digest

Generated: {date}

---

{sections}

---

*End of digest*
```

**Error Handling:**
- Returns empty result on template errors
- Errors are logged but not raised

**Example:**
```python
result = await client.call_tool("combine_markdown_sections", {
    "sections": [markdown_section],
    "template": "default"
})
combined = result["combined_markdown"]
```

---

### 5. convert_markdown_to_pdf

Convert markdown to PDF using weasyprint with CSS styling.

**Request:**
```json
{
  "markdown": "# Channel Digest\n\nContent...",
  "style": "default",
  "metadata": {
    "generation_date": "2024-01-15T20:00:00Z",
    "user_id": 123456789
  }
}
```

**Parameters:**
- `markdown` (str, required): Markdown content string
- `style` (str, optional): Style name (default: "default")
- `metadata` (dict, optional): Optional metadata dict (not used currently)

**Response:**
```json
{
  "pdf_bytes": "JVBERi0xLjQKJeLjz9MKMyAwIG9iago8PC9MZW5ndGggND...",
  "file_size": 24576,
  "pages": 3
}
```

**Response Fields:**
- `pdf_bytes` (str): Base64-encoded PDF bytes
- `file_size` (int): PDF file size in bytes
- `pages` (int): Estimated number of pages

**Error Response:**
```json
{
  "pdf_bytes": "",
  "file_size": 0,
  "pages": 0,
  "error": "Conversion error message"
}
```

**CSS Styling:**
- Font: Arial/Helvetica, 12pt
- Headers: Bold, larger font (h1: 24pt, h2: 18pt)
- Page breaks between major sections
- A4 page size with 2cm margins

**Error Handling:**
- Returns error dict on conversion failures
- Errors are logged but not raised
- Error message included in response dict

**Example:**
```python
result = await client.call_tool("convert_markdown_to_pdf", {
    "markdown": markdown_content,
    "style": "default"
})

if "error" in result:
    print(f"PDF generation failed: {result['error']}")
else:
    import base64
    pdf_bytes = base64.b64decode(result["pdf_bytes"])
    with open("digest.pdf", "wb") as f:
        f.write(pdf_bytes)
```

---

## Complete Workflow Example

```python
from src.presentation.mcp.client import MCPClient
import base64

async def generate_pdf_digest(user_id: int, hours: int = 24):
    """Complete workflow for PDF digest generation."""
    client = MCPClient()
    
    # Step 1: Get posts from database
    posts_result = await client.call_tool("get_posts_from_db", {
        "user_id": user_id,
        "hours": hours
    })
    
    if not posts_result["posts_by_channel"]:
        return None  # No posts found
    
    # Step 2: Summarize each channel
    summaries = []
    for channel_name, posts in posts_result["posts_by_channel"].items():
        summary = await client.call_tool("summarize_posts", {
            "posts": posts,
            "channel_username": channel_name,
            "max_sentences": 5
        })
        summaries.append(summary)
    
    # Step 3: Format as markdown
    metadata = {
        "generation_date": datetime.utcnow().isoformat(),
        "user_id": user_id,
        "channels_count": len(summaries),
        "total_posts": posts_result["total_posts"]
    }
    markdown_result = await client.call_tool("format_digest_markdown", {
        "summaries": summaries,
        "metadata": metadata
    })
    
    # Step 4: Combine sections
    combined_result = await client.call_tool("combine_markdown_sections", {
        "sections": [markdown_result["markdown"]]
    })
    
    # Step 5: Convert to PDF
    pdf_result = await client.call_tool("convert_markdown_to_pdf", {
        "markdown": combined_result["combined_markdown"],
        "metadata": metadata
    })
    
    if "error" in pdf_result:
        raise Exception(f"PDF generation failed: {pdf_result['error']}")
    
    # Decode PDF bytes
    pdf_bytes = base64.b64decode(pdf_result["pdf_bytes"])
    return pdf_bytes
```

---

## Configuration

All tools use settings from `src/infrastructure/config/settings.py`:

- `pdf_max_posts_per_channel` (default: 100) - Max posts per channel
- `pdf_summary_sentences` (default: 5) - Sentences per channel
- `pdf_summary_max_chars` (default: 3000) - Max chars per summary
- `digest_max_channels` (default: 10) - Max channels per digest

## Error Codes

**get_posts_from_db:**
- Empty result: `{"posts_by_channel": {}, "total_posts": 0, "channels_count": 0}`

**summarize_posts:**
- Fallback summary: Returns fallback text on LLM errors

**format_digest_markdown:**
- Error markdown: Returns error message in markdown format

**combine_markdown_sections:**
- Empty result: Returns empty combined markdown on errors

**convert_markdown_to_pdf:**
- Error dict: `{"pdf_bytes": "", "file_size": 0, "pages": 0, "error": "message"}`

## Dependencies

- MongoDB (Motor/AsyncIO) - For post storage
- MCP Client - For tool execution
- LLM Client - For summarization (via existing summarizer)
- weasyprint - For PDF generation
- markdown - For markdown parsing

## Testing

See `tests/presentation/mcp/test_pdf_digest_tools.py` for comprehensive test coverage.

Run tests:
```bash
pytest tests/presentation/mcp/test_pdf_digest_tools.py -v
```

## Backward Compatibility

All tools maintain backward compatibility. Changes to request/response schemas are documented in `tests/contract/test_mcp_tools_schema.py`.

